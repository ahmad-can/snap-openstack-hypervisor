diff --git a/nova/conf/libvirt.py b/nova/conf/libvirt.py
index 0746d4040a..6716eaa40a 100644
--- a/nova/conf/libvirt.py
+++ b/nova/conf/libvirt.py
@@ -1384,7 +1384,7 @@ and ``gid`` must be specified.
 libvirt_remotefs_opts = [
     cfg.StrOpt('remote_filesystem_transport',
                default='ssh',
-               choices=('ssh', 'rsync'),
+               choices=('ssh', 'rsync', 'http'),
                help="""
 libvirt's transport method for remote file operations.
 
@@ -1395,7 +1395,29 @@ compute nodes, other method must be used for:
 * creating file on remote host
 * removing file from remote host
 * copying file to remote host
-""")
+"""),
+    cfg.IntOpt('file_server_port',
+               default=8099,
+               min=1,
+               help='TCP port of the remote file server used by the http '
+                    'RemoteFilesystem driver.'),
+    cfg.IntOpt('file_server_read_timeout',
+               default=900,
+               min=1,
+               help='Read timeout in seconds for HTTP operations in the http '
+                    'RemoteFilesystem driver.'),
+    cfg.StrOpt('file_server_ca_file',
+               default='',
+               help='Path to a CA bundle file to verify the HTTPS file '
+                    'server. If set, verification is enabled using this file.'),
+    cfg.StrOpt('file_server_client_cert_file',
+               default='',
+               help='Path to client certificate file for mutual TLS to the '
+                    'file server.'),
+    cfg.StrOpt('file_server_client_key_file',
+               default='',
+               help='Path to client private key file for mutual TLS to the '
+                    'file server.'),
 ]
 
 libvirt_volume_vzstorage_opts = [
diff --git a/nova/virt/libvirt/volume/remotefs.py b/nova/virt/libvirt/volume/remotefs.py
index 8ddcaa1fcc..8096c77903 100644
--- a/nova/virt/libvirt/volume/remotefs.py
+++ b/nova/virt/libvirt/volume/remotefs.py
@@ -24,6 +24,8 @@ from oslo_utils import importutils
 import nova.conf
 import nova.privsep.fs
 from nova import utils
+from nova.virt.libvirt.volume.remotefs_http import HttpDriver as _HttpDriverImpl
+HttpDriver = _HttpDriverImpl
 
 LOG = logging.getLogger(__name__)
 
diff --git a/nova/virt/libvirt/volume/remotefs_http.py b/nova/virt/libvirt/volume/remotefs_http.py
new file mode 100644
index 0000000000..deeaa34642
--- /dev/null
+++ b/nova/virt/libvirt/volume/remotefs_http.py
@@ -0,0 +1,137 @@
+import os
+import tempfile
+from typing import Tuple
+
+from oslo_log import log as logging
+
+import nova.conf
+
+
+LOG = logging.getLogger(__name__)
+CONF = nova.conf.CONF
+
+
+def _parse_remote_dst(dst: str) -> Tuple[str, str]:
+    # Expected format: "<host>:<absolute_path>"
+    # Example: "10.149.132.154:/var/snap/openstack-hypervisor/common/lib/nova/instances/.../disk"
+    if ":" not in dst:
+        raise ValueError(f"Invalid remote path format, expected 'host:/abs/path', got: {dst}")
+    host, path = dst.split(":", 1)
+    if not path.startswith("/"):
+        raise ValueError(f"Destination path must be absolute, got: {path}")
+    return host, path
+
+
+def _normalize_webdav_path(path: str) -> str:
+    """Convert absolute path to WebDAV-relative path (chrooted to SNAP_COMMON).
+    
+    SFTPGo chroots to SNAP_COMMON, so we need to strip that prefix.
+    Example: /var/snap/openstack-hypervisor/common/lib/nova/disk 
+           -> lib/nova/disk
+    """
+    snap_common = "/var/snap/openstack-hypervisor/common"
+    if path.startswith(snap_common):
+        normalized = path[len(snap_common):].lstrip("/")
+        return normalized
+    # If path doesn't start with SNAP_COMMON, assume it's already relative
+    return path.lstrip("/")
+
+
+def _base_url(host: str) -> str:
+    port = getattr(CONF.libvirt, "file_server_port", 8099)
+    return f"https://{host}:{port}"
+
+
+def _new_client(host: str):
+    # Lazy import to keep dependency surface localized
+    from webdav4.client import Client
+
+    base_url = _base_url(host)
+    # TLS verification and client certs for mTLS
+    # webdav4 uses requests under the hood, so it accepts requests-style kwargs
+    ca_file = getattr(CONF.libvirt, 'file_server_ca_file', '') or True
+    cert_file = getattr(CONF.libvirt, 'file_server_client_cert_file', '') or None
+    key_file = getattr(CONF.libvirt, 'file_server_client_key_file', '') or None
+    client_cert = (cert_file, key_file) if cert_file and key_file else None
+    
+    # Build kwargs for Client constructor
+    # webdav4 Client accepts requests.Session kwargs via **kwargs
+    kwargs = {}
+    if ca_file:
+        kwargs['verify'] = ca_file
+    if client_cert:
+        kwargs['cert'] = client_cert
+    # Read timeout defaults if not configured
+    read_timeout = getattr(CONF.libvirt, "file_server_read_timeout", None)
+    if read_timeout:
+        kwargs['timeout'] = (5, int(read_timeout))
+    else:
+        kwargs['timeout'] = (5, 900)
+    
+    # If webdav4 requires basic auth in addition to mTLS, uncomment:
+    # kwargs['auth'] = ("nova", "")  # username matches SFTPGo config
+    
+    return Client(base_url, **kwargs)
+
+
+class HttpDriver:
+    """HTTP(WebDAV) transport driver implementing RemoteFilesystemDriver API."""
+
+    def create_file(self, host, dst_path, on_execute=None, on_completion=None):
+        LOG.debug("[webdav] create file %s on %s", dst_path, host)
+        client = _new_client(host)
+        webdav_path = _normalize_webdav_path(dst_path)
+        # Create parent directory if needed
+        parent = os.path.dirname(webdav_path.rstrip("/"))
+        if parent and parent != "/":
+            try:
+                client.mkdir(parent)
+            except Exception:
+                # Directory may already exist, ignore
+                pass
+        # PUT empty file using temporary file
+        with tempfile.NamedTemporaryFile(delete=False) as tmp:
+            tmp_path = tmp.name
+        try:
+            client.upload_file(local_path=tmp_path, remote_path=webdav_path)
+        finally:
+            os.unlink(tmp_path)
+
+    def remove_file(self, host, dst_path, on_execute=None, on_completion=None):
+        LOG.debug("[webdav] remove file %s on %s", dst_path, host)
+        client = _new_client(host)
+        webdav_path = _normalize_webdav_path(dst_path)
+        client.remove(webdav_path)
+
+    def create_dir(self, host, dst_path, on_execute=None, on_completion=None):
+        LOG.debug("[webdav] create dir %s on %s", dst_path, host)
+        client = _new_client(host)
+        webdav_path = _normalize_webdav_path(dst_path)
+        try:
+            client.mkdir(webdav_path)
+        except Exception:
+            # Directory may already exist, ignore
+            pass
+
+    def remove_dir(self, host, dst_path, on_execute=None, on_completion=None):
+        LOG.debug("[webdav] remove dir %s on %s", dst_path, host)
+        client = _new_client(host)
+        webdav_path = _normalize_webdav_path(dst_path)
+        client.remove(webdav_path)
+
+    def copy_file(self, src, dst, on_execute=None, on_completion=None, compression=True):
+        # compression ignored: WebDAV handles full-stream PUTs natively
+        LOG.debug("[webdav] upload %s to %s", src, dst)
+        host, dst_path = _parse_remote_dst(dst)
+        client = _new_client(host)
+        webdav_path = _normalize_webdav_path(dst_path)
+        # Ensure destination parent exists
+        parent = os.path.dirname(webdav_path.rstrip("/"))
+        if parent and parent != "/":
+            try:
+                client.mkdir(parent)
+            except Exception:
+                # Directory may already exist, ignore
+                pass
+        # Upload file
+        client.upload_file(local_path=src, remote_path=webdav_path)
diff --git a/requirements.txt b/requirements.txt
index 291ccbd828..ada3688b8a 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -63,3 +63,4 @@ python-dateutil>=2.7.0 # BSD
 futurist>=3.2.1 # Apache-2.0
 openstacksdk>=4.4.0 # Apache-2.0
 PyYAML>=5.1 # MIT
+webdav4>=0.9 # MIT
